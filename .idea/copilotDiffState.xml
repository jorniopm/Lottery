<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/Main.java" />
              <option name="originalContent" value="package app;&#10;&#10;import javafx.application.Application;&#10;import javafx.stage.Stage;&#10;import model.User;&#10;import model.UserLoader;&#10;import view.LotteryView;&#10;import javafx.scene.image.Image;&#10;&#10;import java.util.List;&#10;&#10;public class Main extends Application {&#10;    @Override&#10;    public void start(Stage stage) {&#10;        List&lt;User&gt; users = UserLoader.loadUsers(&quot;data/users.txt&quot;);&#10;        new LotteryView(stage, users);&#10;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        launch();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app;&#10;&#10;import javafx.application.Application;&#10;import javafx.stage.Stage;&#10;import model.User;&#10;import model.UserLoader;&#10;import view.LotteryView;&#10;&#10;import java.util.List;&#10;&#10;public class Main extends Application {&#10;    @Override&#10;    public void start(Stage stage) {&#10;        List&lt;User&gt; users = UserLoader.loadUsers(&quot;data/users.txt&quot;);&#10;        new LotteryView(stage, users);&#10;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        launch();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/controller/LotteryController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/controller/LotteryController.java" />
              <option name="originalContent" value="package controller;&#10;&#10;import javafx.animation.*;&#10;import javafx.util.Duration;&#10;import model.User;&#10;import view.LotteryView;&#10;&#10;import java.util.*;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;&#10;public class LotteryController {&#10;    private final List&lt;User&gt; users;&#10;    private final Set&lt;String&gt; usedIds = new HashSet&lt;&gt;();&#10;    private final Random random = new Random();&#10;    private final LotteryView view;&#10;&#10;    private Timeline timeline;&#10;&#10;    // Store last draw result and simple history&#10;    private List&lt;User&gt; lastWinners = new ArrayList&lt;&gt;();&#10;    private final List&lt;List&lt;User&gt;&gt; history = new ArrayList&lt;&gt;();&#10;&#10;    public LotteryController(List&lt;User&gt; users, LotteryView view) {&#10;        this.users = new ArrayList&lt;&gt;(users);&#10;        this.view = view;&#10;    }&#10;&#10;    public void start() {&#10;        boolean repeatAllowed = view.isRepeatAllowed();&#10;        if (!repeatAllowed &amp;&amp; usedIds.size() == users.size()) {&#10;            view.showMessage(&quot;所有人都已被抽过！&quot;, new ArrayList&lt;&gt;());&#10;            return;&#10;        }&#10;        if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING)&#10;            return;&#10;&#10;        timeline = new Timeline(new KeyFrame(Duration.millis(80), e -&gt; showRandomUser()));&#10;        timeline.setCycleCount(Animation.INDEFINITE);&#10;        timeline.play();&#10;    }&#10;&#10;    public void stop() {&#10;        if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {&#10;            timeline.stop();&#10;            int count = view.getDrawCount();&#10;            boolean repeatAllowed = view.isRepeatAllowed();&#10;&#10;            List&lt;User&gt; winners = new ArrayList&lt;&gt;();&#10;&#10;            // Build a temporary pool for THIS single draw so we don't pick the same person twice&#10;            // within the same stop() invocation. This respects global `usedIds` only when&#10;            // repeatAllowed == false (i.e. people already drawn in previous rounds are excluded).&#10;            List&lt;User&gt; pool = new ArrayList&lt;&gt;(users);&#10;            if (!repeatAllowed) {&#10;                pool.removeIf(u -&gt; usedIds.contains(u.getId()));&#10;            }&#10;&#10;            // Cap the number of winners to the pool size to avoid infinite loops&#10;            int picks = Math.min(count, pool.size());&#10;            for (int i = 0; i &lt; picks; i++) {&#10;                if (pool.isEmpty()) break;&#10;                User selected = pool.remove(random.nextInt(pool.size()));&#10;                winners.add(selected);&#10;                // If repeats are not allowed across rounds, mark selected as used globally&#10;                if (!repeatAllowed) {&#10;                    usedIds.add(selected.getId());&#10;                }&#10;            }&#10;&#10;            // Save last winners and append to history&#10;            lastWinners = new ArrayList&lt;&gt;(winners);&#10;            if (!lastWinners.isEmpty()) {&#10;                history.add(new ArrayList&lt;&gt;(lastWinners));&#10;            }&#10;&#10;            view.showMessage(&quot;中奖名单：&quot;, winners);&#10;        }&#10;    }&#10;&#10;    private User drawOne(boolean repeatAllowed) {&#10;        List&lt;User&gt; available = new ArrayList&lt;&gt;(users);&#10;        if (!repeatAllowed) {&#10;            available.removeIf(u -&gt; usedIds.contains(u.getId()));&#10;        }&#10;        if (available.isEmpty()) return null;&#10;        User selected = available.get(random.nextInt(available.size()));&#10;        if (!repeatAllowed) usedIds.add(selected.getId());&#10;        return selected;&#10;    }&#10;&#10;    private void showRandomUser() {&#10;        int count = view.getDrawCount();&#10;        boolean repeatAllowed = view.isRepeatAllowed();&#10;        List&lt;User&gt; usersToDisplay = new ArrayList&lt;&gt;();&#10;&#10;        List&lt;User&gt; availableUsersForRandom = new ArrayList&lt;&gt;(users);&#10;        if (!repeatAllowed) {&#10;            availableUsersForRandom.removeIf(u -&gt; usedIds.contains(u.getId()));&#10;        }&#10;&#10;        if (availableUsersForRandom.isEmpty()) {&#10;            view.showMessage(&quot;所有人都已被抽过！&quot;, new ArrayList&lt;&gt;());&#10;            if (timeline != null) {&#10;                timeline.stop();&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Select 'count' random users for display during scrolling.&#10;        // Remove selected items from the temporary list to avoid duplicates within the&#10;        // same frame (so the same person doesn't appear more than once in that display).&#10;        for (int i = 0; i &lt; count; i++) {&#10;            if (availableUsersForRandom.isEmpty()) {&#10;                break; // Not enough users to display 'count' unique users&#10;            }&#10;            User user = availableUsersForRandom.remove(random.nextInt(availableUsersForRandom.size()));&#10;            usersToDisplay.add(user);&#10;        }&#10;        view.updateDisplay(usersToDisplay);&#10;    }&#10;&#10;    // Export the latest draw result to CSV&#10;    public boolean exportLastWinnersToCSV(File file) {&#10;        if (lastWinners == null || lastWinners.isEmpty() || file == null) {&#10;            return false;&#10;        }&#10;        DateTimeFormatter fmt = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);&#10;        String drawTime = LocalDateTime.now().format(fmt);&#10;        try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {&#10;            // UTF-8 BOM for Excel compatibility on Windows&#10;            bw.write('\uFEFF');&#10;            bw.write(&quot;编号,姓名,照片路径,抽取时间&quot;);&#10;            bw.newLine();&#10;            for (User u : lastWinners) {&#10;                String id = safe(u.getId());&#10;                String name = safe(u.getName());&#10;                String photo = safe(u.getPhotoPath());&#10;                bw.write(String.join(&quot;,&quot;, escapeCsv(id), escapeCsv(name), escapeCsv(photo), escapeCsv(drawTime)));&#10;                bw.newLine();&#10;            }&#10;            bw.flush();&#10;            return true;&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private static String safe(String s) { return s == null ? &quot;&quot; : s; }&#10;&#10;    private static String escapeCsv(String s) {&#10;        if (s.contains(&quot;,&quot;) || s.contains(&quot;\&quot;&quot;) || s.contains(&quot;\n&quot;) || s.contains(&quot;\r&quot;)) {&#10;            s = s.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;);&#10;            return &quot;\&quot;&quot; + s + &quot;\&quot;&quot;;&#10;        }&#10;        return s;&#10;    }&#10;&#10;    public boolean hasLastWinners() {&#10;        return lastWinners != null &amp;&amp; !lastWinners.isEmpty();&#10;    }&#10;&#10;    // Allow replacing the roster safely&#10;    public void replaceUsers(List&lt;User&gt; newUsers) {&#10;        // Stop timeline if running&#10;        if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {&#10;            timeline.stop();&#10;        }&#10;        // Replace list contents without reassigning the final reference&#10;        users.clear();&#10;        if (newUsers != null) {&#10;            users.addAll(newUsers);&#10;        }&#10;        // Reset state&#10;        usedIds.clear();&#10;        lastWinners = new ArrayList&lt;&gt;();&#10;        history.clear();&#10;    }&#10;&#10;    // Snapshot of current users for preview&#10;    public List&lt;User&gt; getUsersSnapshot() {&#10;        return new ArrayList&lt;&gt;(users);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package controller;&#10;&#10;import javafx.animation.*;&#10;import javafx.util.Duration;&#10;import model.User;&#10;import view.LotteryView;&#10;&#10;import java.util.*;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;&#10;public class LotteryController {&#10;    private final List&lt;User&gt; users;&#10;    private final Set&lt;String&gt; usedIds = new HashSet&lt;&gt;();&#10;    private final Random random = new Random();&#10;    private final LotteryView view;&#10;&#10;    private Timeline timeline;&#10;&#10;    // Store last draw result&#10;    private List&lt;User&gt; lastWinners = new ArrayList&lt;&gt;();&#10;&#10;    public LotteryController(List&lt;User&gt; users, LotteryView view) {&#10;        this.users = new ArrayList&lt;&gt;(users);&#10;        this.view = view;&#10;    }&#10;&#10;    public void start() {&#10;        boolean repeatAllowed = view.isRepeatAllowed();&#10;        if (!repeatAllowed &amp;&amp; usedIds.size() == users.size()) {&#10;            view.showMessage(&quot;所有人都已被抽过！&quot;, new ArrayList&lt;&gt;());&#10;            return;&#10;        }&#10;        if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING)&#10;            return;&#10;&#10;        timeline = new Timeline(new KeyFrame(Duration.millis(80), e -&gt; showRandomUser()));&#10;        timeline.setCycleCount(Animation.INDEFINITE);&#10;        timeline.play();&#10;    }&#10;&#10;    public void stop() {&#10;        if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {&#10;            timeline.stop();&#10;            int count = view.getDrawCount();&#10;            boolean repeatAllowed = view.isRepeatAllowed();&#10;&#10;            List&lt;User&gt; winners = new ArrayList&lt;&gt;();&#10;&#10;            // Build a temporary pool for THIS single draw so we don't pick the same person twice&#10;            // within the same stop() invocation. This respects global `usedIds` only when&#10;            // repeatAllowed == false (i.e. people already drawn in previous rounds are excluded).&#10;            List&lt;User&gt; pool = new ArrayList&lt;&gt;(users);&#10;            if (!repeatAllowed) {&#10;                pool.removeIf(u -&gt; usedIds.contains(u.getId()));&#10;            }&#10;&#10;            // Cap the number of winners to the pool size to avoid infinite loops&#10;            int picks = Math.min(count, pool.size());&#10;            for (int i = 0; i &lt; picks; i++) {&#10;                if (pool.isEmpty()) break;&#10;                User selected = pool.remove(random.nextInt(pool.size()));&#10;                winners.add(selected);&#10;                // If repeats are not allowed across rounds, mark selected as used globally&#10;                if (!repeatAllowed) {&#10;                    usedIds.add(selected.getId());&#10;                }&#10;            }&#10;&#10;            // Save last winners&#10;            lastWinners = new ArrayList&lt;&gt;(winners);&#10;&#10;            view.showMessage(&quot;中奖名单：&quot;, winners);&#10;        }&#10;    }&#10;&#10;    private void showRandomUser() {&#10;        int count = view.getDrawCount();&#10;        boolean repeatAllowed = view.isRepeatAllowed();&#10;        List&lt;User&gt; usersToDisplay = new ArrayList&lt;&gt;();&#10;&#10;        List&lt;User&gt; availableUsersForRandom = new ArrayList&lt;&gt;(users);&#10;        if (!repeatAllowed) {&#10;            availableUsersForRandom.removeIf(u -&gt; usedIds.contains(u.getId()));&#10;        }&#10;&#10;        if (availableUsersForRandom.isEmpty()) {&#10;            view.showMessage(&quot;所有人都已被抽过！&quot;, new ArrayList&lt;&gt;());&#10;            if (timeline != null) {&#10;                timeline.stop();&#10;            }&#10;            return;&#10;        }&#10;&#10;        // Select 'count' random users for display during scrolling.&#10;        // Remove selected items from the temporary list to avoid duplicates within the&#10;        // same frame (so the same person doesn't appear more than once in that display).&#10;        for (int i = 0; i &lt; count; i++) {&#10;            if (availableUsersForRandom.isEmpty()) {&#10;                break; // Not enough users to display 'count' unique users&#10;            }&#10;            User user = availableUsersForRandom.remove(random.nextInt(availableUsersForRandom.size()));&#10;            usersToDisplay.add(user);&#10;        }&#10;        view.updateDisplay(usersToDisplay);&#10;    }&#10;&#10;    // Export the latest draw result to CSV&#10;    public boolean exportLastWinnersToCSV(File file) {&#10;        if (lastWinners == null || lastWinners.isEmpty() || file == null) {&#10;            return false;&#10;        }&#10;        DateTimeFormatter fmt = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);&#10;        String drawTime = LocalDateTime.now().format(fmt);&#10;        try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {&#10;            // UTF-8 BOM for Excel compatibility on Windows&#10;            bw.write('\uFEFF');&#10;            bw.write(&quot;编号,姓名,照片路径,抽取时间&quot;);&#10;            bw.newLine();&#10;            for (User u : lastWinners) {&#10;                String id = safe(u.getId());&#10;                String name = safe(u.getName());&#10;                String photo = safe(u.getPhotoPath());&#10;                bw.write(String.join(&quot;,&quot;, escapeCsv(id), escapeCsv(name), escapeCsv(photo), escapeCsv(drawTime)));&#10;                bw.newLine();&#10;            }&#10;            bw.flush();&#10;            return true;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;导出 CSV 时发生错误: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private static String safe(String s) { return s == null ? &quot;&quot; : s; }&#10;&#10;    private static String escapeCsv(String s) {&#10;        if (s.contains(&quot;,&quot;) || s.contains(&quot;\&quot;&quot;) || s.contains(&quot;\n&quot;) || s.contains(&quot;\r&quot;)) {&#10;            s = s.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;);&#10;            return &quot;\&quot;&quot; + s + &quot;\&quot;&quot;;&#10;        }&#10;        return s;&#10;    }&#10;&#10;    public boolean hasLastWinners() {&#10;        return lastWinners != null &amp;&amp; !lastWinners.isEmpty();&#10;    }&#10;&#10;    // Allow replacing the roster safely&#10;    public void replaceUsers(List&lt;User&gt; newUsers) {&#10;        // Stop timeline if running&#10;        if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {&#10;            timeline.stop();&#10;        }&#10;        // Replace list contents without reassigning the final reference&#10;        users.clear();&#10;        if (newUsers != null) {&#10;            users.addAll(newUsers);&#10;        }&#10;        // Reset state&#10;        usedIds.clear();&#10;        lastWinners = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    // Snapshot of current users for preview&#10;    public List&lt;User&gt; getUsersSnapshot() {&#10;        return new ArrayList&lt;&gt;(users);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/model/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/model/User.java" />
              <option name="originalContent" value="package model;&#10;&#10;import javafx.scene.image.Image;&#10;&#10;public class User {&#10;        private String id;&#10;        private String name;&#10;        private String photoPath;&#10;        private Image roundedImage; // 缓存圆角头像&#10;&#10;        public User(String id, String name, String photoPath) {&#10;            this.id = id;&#10;            this.name = name;&#10;            this.photoPath = photoPath;&#10;        }&#10;&#10;        public String getId() { return id; }&#10;        public String getName() { return name; }&#10;        public String getPhotoPath() { return photoPath; }&#10;    public Image getRoundedImage() { return roundedImage; }&#10;    public void setRoundedImage(Image roundedImage) { this.roundedImage = roundedImage; }&#10;}&#10;" />
              <option name="updatedContent" value="package model;&#10;&#10;public class User {&#10;        private final String id;&#10;        private final String name;&#10;        private final String photoPath;&#10;&#10;        public User(String id, String name, String photoPath) {&#10;            this.id = id;&#10;            this.name = name;&#10;            this.photoPath = photoPath;&#10;        }&#10;&#10;        public String getId() { return id; }&#10;        public String getName() { return name; }&#10;        public String getPhotoPath() { return photoPath; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/model/UserLoader.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/model/UserLoader.java" />
              <option name="originalContent" value="package model;&#10;&#10;import javafx.scene.SnapshotParameters;&#10;import javafx.scene.image.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.shape.Rectangle;&#10;&#10;import java.io.*;&#10;import java.util.*;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class UserLoader {&#10;&#10;    public static List&lt;User&gt; loadUsers(String filePath) {&#10;        List&lt;User&gt; users = new ArrayList&lt;&gt;();&#10;        File csvFile = new File(filePath);&#10;        File csvDir = csvFile.getParentFile();&#10;        File imagesDir = new File(&quot;images&quot;);&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(csvFile), StandardCharsets.UTF_8))) {&#10;            String line;&#10;            boolean firstLine = true;&#10;            while ((line = br.readLine()) != null) {&#10;                if (firstLine) {&#10;                    // strip UTF-8 BOM if present&#10;                    if (!line.isEmpty() &amp;&amp; line.charAt(0) == '\uFEFF') {&#10;                        line = line.substring(1);&#10;                    }&#10;                    firstLine = false;&#10;                }&#10;                if (line.trim().isEmpty()) continue;&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 2) {&#10;                    String id = parts[0].trim();&#10;                    String name = parts[1].trim();&#10;                    String photoPathRaw = parts.length &gt;= 3 ? parts[2].trim() : &quot;&quot;;&#10;&#10;                    File resolved = resolvePhotoFile(photoPathRaw, id, name, csvDir, imagesDir);&#10;                    String finalPhotoPath = resolved != null ? resolved.getPath() : photoPathRaw;&#10;&#10;                    System.out.println(&quot;UserLoader: Loading user: &quot; + id + &quot;, Name: &quot; + name + &quot;, Photo Path: &quot; + finalPhotoPath);&#10;&#10;                    Image roundedImage = createRoundedImage(finalPhotoPath, 113, 150);&#10;                    User user = new User(id, name, finalPhotoPath);&#10;                    user.setRoundedImage(roundedImage);&#10;                    users.add(user);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        return users;&#10;    }&#10;&#10;    private static File resolvePhotoFile(String raw, String id, String name, File csvDir, File imagesDir) {&#10;        // Try raw as-is&#10;        if (raw != null &amp;&amp; !raw.isEmpty()) {&#10;            File f = new File(raw);&#10;            if (f.isAbsolute() &amp;&amp; f.exists()) return f;&#10;            // relative to CSV directory&#10;            if (csvDir != null) {&#10;                File relCsv = new File(csvDir, raw);&#10;                if (relCsv.exists()) return relCsv;&#10;            }&#10;            // relative to working dir&#10;            File relWd = new File(System.getProperty(&quot;user.dir&quot;), raw);&#10;            if (relWd.exists()) return relWd;&#10;            // relative to images dir&#10;            if (imagesDir != null) {&#10;                File relImg = new File(imagesDir, raw);&#10;                if (relImg.exists()) return relImg;&#10;            }&#10;            // try by filename only, in images dir&#10;            String fileName = new File(raw).getName();&#10;            if (imagesDir != null) {&#10;                File byName = new File(imagesDir, fileName);&#10;                if (byName.exists()) return byName;&#10;            }&#10;        }&#10;        // Try infer by id/name with common extensions in images dir&#10;        String[] exts = {&quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.bmp&quot;, &quot;.gif&quot;, &quot;.webp&quot;};&#10;        if (imagesDir != null) {&#10;            for (String ext : exts) {&#10;                if (id != null &amp;&amp; !id.isEmpty()) {&#10;                    File f = new File(imagesDir, id + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;                if (name != null &amp;&amp; !name.isEmpty()) {&#10;                    File f = new File(imagesDir, name + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;            }&#10;        }&#10;        // Try infer relative to CSV dir too&#10;        if (csvDir != null) {&#10;            for (String ext : new String[]{&quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.bmp&quot;, &quot;.gif&quot;, &quot;.webp&quot;}) {&#10;                if (id != null &amp;&amp; !id.isEmpty()) {&#10;                    File f = new File(csvDir, id + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;                if (name != null &amp;&amp; !name.isEmpty()) {&#10;                    File f = new File(csvDir, name + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static Image createRoundedImage(String path, double width, double height) {&#10;        try {&#10;            if (path == null || path.isEmpty()) return null;&#10;            File f = new File(path);&#10;            if (!f.isAbsolute()) {&#10;                f = new File(System.getProperty(&quot;user.dir&quot;), path);&#10;            }&#10;            if (!f.exists()) {&#10;                return null;&#10;            }&#10;            Image img = new Image(f.toURI().toString(), width, height, false, true);&#10;&#10;            Rectangle clip = new Rectangle(width, height);&#10;            clip.setArcWidth(15);&#10;            clip.setArcHeight(15);&#10;&#10;            ImageView iv = new ImageView(img);&#10;            iv.setFitWidth(width);&#10;            iv.setFitHeight(height);&#10;            iv.setPreserveRatio(false);&#10;            iv.setClip(clip);&#10;&#10;            SnapshotParameters params = new SnapshotParameters();&#10;            params.setFill(Color.TRANSPARENT);&#10;&#10;            return iv.snapshot(params, null);&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;无法加载图片：&quot; + path);&#10;            return null;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package model;&#10;&#10;import java.io.*;&#10;import java.util.*;&#10;import java.nio.charset.StandardCharsets;&#10;&#10;public class UserLoader {&#10;&#10;    public static List&lt;User&gt; loadUsers(String filePath) {&#10;        List&lt;User&gt; users = new ArrayList&lt;&gt;();&#10;        File csvFile = new File(filePath);&#10;        File csvDir = csvFile.getParentFile();&#10;        File imagesDir = new File(&quot;images&quot;);&#10;        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(csvFile), StandardCharsets.UTF_8))) {&#10;            String line;&#10;            boolean firstLine = true;&#10;            while ((line = br.readLine()) != null) {&#10;                if (firstLine) {&#10;                    // strip UTF-8 BOM if present&#10;                    if (!line.isEmpty() &amp;&amp; line.charAt(0) == '\uFEFF') {&#10;                        line = line.substring(1);&#10;                    }&#10;                    firstLine = false;&#10;                }&#10;                if (line.trim().isEmpty()) continue;&#10;                String[] parts = line.split(&quot;,&quot;);&#10;                if (parts.length &gt;= 2) {&#10;                    String id = parts[0].trim();&#10;                    String name = parts[1].trim();&#10;                    String photoPathRaw = parts.length &gt;= 3 ? parts[2].trim() : &quot;&quot;;&#10;&#10;                    File resolved = resolvePhotoFile(photoPathRaw, id, name, csvDir, imagesDir);&#10;                    String finalPhotoPath = resolved != null ? resolved.getPath() : &quot;&quot;;&#10;&#10;                    User user = new User(id, name, finalPhotoPath);&#10;                    users.add(user);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            // Let caller handle empty or failed load by returning empty list&#10;        }&#10;        return users;&#10;    }&#10;&#10;    private static File resolvePhotoFile(String raw, String id, String name, File csvDir, File imagesDir) {&#10;        // Try raw as-is&#10;        if (raw != null &amp;&amp; !raw.isEmpty()) {&#10;            File f = new File(raw);&#10;            if (f.isAbsolute() &amp;&amp; f.exists()) return f;&#10;            // relative to CSV directory&#10;            if (csvDir != null) {&#10;                File relCsv = new File(csvDir, raw);&#10;                if (relCsv.exists()) return relCsv;&#10;            }&#10;            // relative to working dir&#10;            File relWd = new File(System.getProperty(&quot;user.dir&quot;), raw);&#10;            if (relWd.exists()) return relWd;&#10;            // relative to images dir&#10;            if (imagesDir != null) {&#10;                File relImg = new File(imagesDir, raw);&#10;                if (relImg.exists()) return relImg;&#10;            }&#10;            // try by filename only, in images dir&#10;            String fileName = new File(raw).getName();&#10;            if (imagesDir != null) {&#10;                File byName = new File(imagesDir, fileName);&#10;                if (byName.exists()) return byName;&#10;            }&#10;        }&#10;        // Try infer by id/name with common extensions in images dir&#10;        String[] exts = {&quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.bmp&quot;, &quot;.gif&quot;, &quot;.webp&quot;};&#10;        if (imagesDir != null) {&#10;            for (String ext : exts) {&#10;                if (id != null &amp;&amp; !id.isEmpty()) {&#10;                    File f = new File(imagesDir, id + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;                if (name != null &amp;&amp; !name.isEmpty()) {&#10;                    File f = new File(imagesDir, name + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;            }&#10;        }&#10;        // Try infer relative to CSV dir too&#10;        if (csvDir != null) {&#10;            for (String ext : new String[]{&quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.bmp&quot;, &quot;.gif&quot;, &quot;.webp&quot;}) {&#10;                if (id != null &amp;&amp; !id.isEmpty()) {&#10;                    File f = new File(csvDir, id + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;                if (name != null &amp;&amp; !name.isEmpty()) {&#10;                    File f = new File(csvDir, name + ext);&#10;                    if (f.exists()) return f;&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>